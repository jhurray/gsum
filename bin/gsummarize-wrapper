#!/bin/bash

# Architecture-focused directory summarizer for condensed AI context

DIR="${1:-.}"

# Change to target directory so Gemini analyzes the right location
cd "$DIR" || exit 1

# Create a temporary file to capture Gemini output and errors
TEMP_OUTPUT=$(mktemp)
TEMP_ERROR=$(mktemp)

# Function to clean up temp files
cleanup() {
    rm -f "$TEMP_OUTPUT" "$TEMP_ERROR"
}
trap cleanup EXIT

# Run gemini with architecture-focused prompt and capture both stdout and stderr
gemini --yolo > "$TEMP_OUTPUT" 2> "$TEMP_ERROR" << 'EOF'
You are a senior software engineer, architect, and tech lead. 
- You are an expert in the field of software engineering and architecture. 
- You are also a great communicator and writer. You are able to write in a way that is easy to understand and follow.
- You are also able to write in a way that is concise and to the point. 
- You are also able to write in a way that is engaging and interesting to read. 
- You are also able to write in a way that is accurate and correct. 
- You are also able to write in a way that is helpful and useful to the reader. 
- You are also able to write in a way that is easy to understand and follow.

Your task is to create a comprehensive ARCHITECTURE & TECHNICAL SPECIFICATION document for this codebase. This will be used as condensed context for AI agents to understand how to work with this project.

IMPORTANT: 
- Focus on architecture, not file listings
- Respect .gitignore - skip node_modules, build outputs, etc.
- Think like a senior engineer onboarding someone new
- Include actual code examples for key patterns

Structure the document as follows:

# PROJECT OVERVIEW
- Project name and purpose
- What problem it solves
- Target users/audience
- Current development status
- Key features and capabilities

# SETUP & GETTING STARTED
- Prerequisites (Node version, dependencies, etc.)
- Installation steps from README
- Environment variables needed
- How to run in development
- How to build for production
- Common troubleshooting

# ARCHITECTURE OVERVIEW
- High-level architecture (frontend/backend/database/tooling/setup/etc..)
- Technology choices and why
- Design patterns used
- Data flow overview
- State management approach
- Authentication/authorization architecture

# PROJECT STRUCTURE
Explain the directory organization:
```
src/
├── components/     # [Explain what goes here]
├── pages/         # [Explain routing approach]
├── lib/           # [Explain utilities]
└── ...
```

# KEY MODULES & COMPONENTS

For each major module/directory:
## Module Name
- Purpose and responsibility
- Key files and their roles
- Interfaces/APIs it exposes
- Dependencies and interactions
- Code patterns used

Include actual code snippets showing typical patterns:
```typescript
// Example component structure
// Example API endpoint
// Example utility function
```

# DATABASE & DATA MODELS
- Database schema overview
- Key tables/collections and relationships
- Migration approach
- Data access patterns
- Example queries

# API DESIGN
- API structure (REST/GraphQL/tRPC)
- Authentication approach
- Endpoint naming conventions
- Request/response formats
- Error handling patterns
- Example API calls

# FRONTEND ARCHITECTURE
- Component hierarchy
- Routing structure
- State management details
- Data fetching patterns
- UI component library
- Styling approach (CSS/Tailwind/etc)
- Form handling
- Client-side validation

# BUSINESS LOGIC
- Where business rules live
- How features are implemented
- Service layer patterns
- Data validation approach
- Error handling strategy

# TESTING STRATEGY
- Test file locations
- Testing frameworks used
- What to test and how
- Running tests
- Test data approach

# DEPLOYMENT & CONFIGURATION
- Build process
- Deployment targets
- Environment-specific configs
- CI/CD pipeline
- Monitoring approach

# DEVELOPMENT WORKFLOW
- Git branch strategy
- Code review process
- Coding standards
- Important scripts in package.json
- Debugging tips

# SECURITY CONSIDERATIONS
- Authentication implementation
- Authorization checks
- Data validation
- API security
- Secrets management

# PERFORMANCE OPTIMIZATIONS
- Caching strategies
- Database query optimization
- Frontend optimizations
- Bundle size management

# IMPORTANT PATTERNS & CONVENTIONS
- Naming conventions
- File organization rules
- Code style guidelines
- Common utilities to use
- Patterns to follow/avoid

# CURRENT LIMITATIONS & TECH DEBT
- Known issues
- Areas needing refactoring
- Performance bottlenecks
- Missing features

# INTEGRATION POINTS
- External services used
- API integrations
- Webhook handlers
- Third-party libraries

# ADDING NEW FEATURES
Step-by-step guide:
1. Where to add new routes
2. How to create new components
3. Database migration process
4. API endpoint creation
5. Testing requirements

Include code templates for common tasks.

Now use the summarize_directory tool to create this architecture-focused technical specification. Make sure to:
1. Set the outputFile parameter to "DIRECTORY_SUMMARY.md" (not ARCHITECTURE.md)
2. Create an EXTREMELY detailed document - aim for 10,000+ words
3. Include actual code examples from the project
4. Be exhaustive in documenting every aspect
EOF

# Capture exit code
GEMINI_EXIT_CODE=$?

# Check for common error patterns in stderr AND stdout
ERROR_CONTENT=""
if [ -s "$TEMP_ERROR" ]; then
    ERROR_CONTENT=$(cat "$TEMP_ERROR")
fi

# Also check stdout for error patterns (sometimes errors go to stdout)
if [ -s "$TEMP_OUTPUT" ]; then
    OUTPUT_CONTENT=$(cat "$TEMP_OUTPUT")
    ERROR_CONTENT="$ERROR_CONTENT$OUTPUT_CONTENT"
fi

# Check for specific error patterns in the content
if [ -n "$ERROR_CONTENT" ]; then
    # Check for quota exceeded error
    if echo "$ERROR_CONTENT" | grep -qi "quota exceeded\|resource_exhausted\|rateLimitExceeded"; then
        echo "❌ ERROR: Gemini API quota exceeded"
        echo ""
        echo "Your Gemini API quota has been reached for today. This usually means:"
        echo "• You've hit the daily request limit for Gemini 2.5 Pro"
        echo "• The quota typically resets at midnight Pacific Time"
        echo ""
        echo "Solutions:"
        echo "1. Wait until tomorrow for quota reset"
        echo "2. Check your Google Cloud Console for quota status:"
        echo "   https://console.cloud.google.com/apis/api/generativelanguage.googleapis.com"
        echo "3. Consider upgrading your API plan if you need higher limits"
        echo ""
        echo "For more details on Gemini API quotas, see:"
        echo "https://ai.google.dev/gemini-api/docs/rate-limits"
        exit 1
    
    # Check for authentication errors
    elif echo "$ERROR_CONTENT" | grep -qi "authentication\|unauthorized\|permission denied"; then
        echo "❌ ERROR: Gemini API authentication failed"
        echo ""
        echo "Please check your Gemini API setup:"
        echo "1. Ensure you have a valid API key configured"
        echo "2. Check that the Gemini CLI is properly installed"
        echo "3. Verify your API key has the necessary permissions"
        echo ""
        echo "For setup instructions, see:"
        echo "https://github.com/google/generative-ai-docs/tree/main/gemini-cli"
        exit 1
    
    # Check for network errors
    elif echo "$ERROR_CONTENT" | grep -qi "network\|connection\|timeout"; then
        echo "❌ ERROR: Network connection failed"
        echo ""
        echo "Unable to connect to Gemini API. Please check:"
        echo "1. Your internet connection"
        echo "2. Firewall settings"
        echo "3. Google Cloud service status"
        echo ""
        echo "Error details:"
        echo "$ERROR_CONTENT" | head -3
        exit 1
    
    # Check for other actual error patterns
    elif echo "$ERROR_CONTENT" | grep -qi "error\|failed\|exception\|gaxioserror\|attempt.*failed"; then
        echo "❌ ERROR: Gemini API request failed"
        echo ""
        echo "Error details:"
        echo "$ERROR_CONTENT" | head -5
        echo ""
        echo "If this persists, try:"
        echo "1. Checking your API key and permissions"
        echo "2. Verifying Gemini CLI installation: gemini --version"
        echo "3. Testing a simple Gemini request manually"
        exit 1
    fi
    # If no error patterns are found, continue (stderr might just be informational)
fi

# Check if gemini command failed
if [ $GEMINI_EXIT_CODE -ne 0 ]; then
    echo "❌ ERROR: Gemini command failed with exit code $GEMINI_EXIT_CODE"
    
    if [ -s "$TEMP_ERROR" ]; then
        echo ""
        echo "Error output:"
        cat "$TEMP_ERROR"
    fi
    
    exit $GEMINI_EXIT_CODE
fi

# Check if the expected DIRECTORY_SUMMARY.md file was created (normal case)
if [ -f "DIRECTORY_SUMMARY.md" ]; then
    # Success - the MCP tool created the file as expected
    exit 0
fi

# If no file was created, check if we have stdout output (fallback case)
if [ -s "$TEMP_OUTPUT" ]; then
    # Check if the output contains error patterns (sometimes Gemini outputs errors to stdout)
    OUTPUT_CONTENT=$(cat "$TEMP_OUTPUT")
    if echo "$OUTPUT_CONTENT" | grep -qi "quota exceeded\|resource_exhausted\|rateLimitExceeded\|gaxioserror\|attempt.*failed"; then
        echo "❌ ERROR: Gemini API request failed (detected error in output)"
        echo ""
        echo "The output contains error information instead of a valid summary."
        echo "This usually indicates API quota or authentication issues."
        echo ""
        echo "First few lines of error output:"
        echo "$OUTPUT_CONTENT" | head -5
        exit 1
    fi
    
    # Output the result to stdout (fallback for direct output mode)
    cat "$TEMP_OUTPUT"
    exit 0
fi

# Neither file nor output was generated
echo "❌ ERROR: No summary was generated"
echo ""
echo "Neither DIRECTORY_SUMMARY.md file nor stdout output was created."
echo "This could indicate:"
echo "1. API quota issues"
echo "2. Authentication problems"
echo "3. Network connectivity issues"

if [ -s "$TEMP_ERROR" ]; then
    echo ""
    echo "Error details:"
    cat "$TEMP_ERROR"
fi

exit 1